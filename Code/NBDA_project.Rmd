---
title: "Project Network-based Data Analysis"
author: "Annalisa Xamin"
output: 
  pdf_document:
    latex_engine: xelatex
    toc: true
  html_document:
    toc: true
    df_print: paged
always_allow_html: true
---
```{r, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
# knitr::opts_chunk$set(cache = TRUE)
setwd("~/Repo_Git/NBDA/Code")
```


```{r packages, warning=FALSE, results='hide', message=FALSE, include=FALSE}

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

if (!require("GEOquery", quietly = TRUE))
    BiocManager::install("GEOquery") 

if (!require("rScudo", quietly = TRUE))
    BiocManager::install("rScudo") 

if (!require("limma", quietly = TRUE))
    BiocManager::install("limma") 

if (!require("EnhancedVolcano", quietly = TRUE))
    BiocManager::install("EnhancedVolcano") 

library(tidyverse)
library(dplyr)
library(GEOquery)
library(rScudo)
library(plotly)
library(sessioninfo)
library(ggplot2)
library(factoextra)
library(useful)
library(umap)
library(ggpubr)
library(limma)
library(EnhancedVolcano)
library(magrittr)
library(cluster)
library(randomForest)
library(RColorBrewer)

my_colors <- c("#2e005d", "#5c008b", "#8e008b", "#ff8300", "#ff6200", "#d1105a", "#05a8aa")
```

```{r session info, warning=FALSE, include=FALSE}
print('Reproducibility information:') 
Sys.time()
proc.time()
options(width = 120)
session_info()
```

# Data selection

The analysis will use the dataset [GSE20437](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE20437) obtained from GEO.The dataset is generated from Affymetrix HU133A microarrays and contains 42 tissue samples. 

In detail, the data includes:

- 18 reduction mammoplasty (RM) breast epithelium samples, 

- 18 histologically normal (HN) epithelial samples from breast cancer patients (9 ER+ and 9 ER-), and

- 6 histologically normal epithelial samples from prophylactic mastectomy patients. 

Note that sample numbers correspond to individual patient samples.

```{r retrieve data from GEO}
# download the GSE20437 expression data series
#gse <- getGEO("GSE20437", destdir= './data/', getGPL = F)

# load the local copy of the data
gse <- getGEO(file = "./data/GSE20437_series_matrix.txt.gz", getGPL = FALSE)
```

```{r}
# getGEO returns a list of expression objects, but...
length(gse) 
# shows us there is only one object in it. 
# We assign it to the same variable.
#gse <- gse[[1]] # run only if you download data and 
# if you don't use the local copy
```

```{r retrieve metadata}
# extract metadata
metadata <- data.frame(gse@phenoData@data)
```

```{r save metadata to csv file, include=FALSE}
# save metadata to csv file
write.csv(metadata, file = 'output/metadata.csv', row.names = TRUE)
```


```{r plot groups, warning=FALSE}
p <- ggplot(metadata, aes(x=disease.state.ch1, fill=specimen.ch1))+
  geom_bar()+
  scale_fill_manual(values = my_colors[c(1,4,6,7)])
p + labs(x = "Group") 

```
```{r, include=FALSE}
# save plot as pdf
pdf("plots/01_plot_groups.pdf")
p <- ggplot(metadata, aes(x=disease.state.ch1, fill=specimen.ch1))+
  geom_bar()+
  scale_fill_manual(values = my_colors[c(1,4,6,7)])
p + labs(x = "Group") 
dev.off()
```


```{r, include=FALSE}
head(metadata)
```


# Exploratory analysis
```{r}
# show what we have:
show(gse)
```

The actual expression data are accessible in the `exprs` section of `gse`, an Expression Set and the generic data class that BioConductor uses for expression data.

```{r inspect exprs}
head(exprs(gse)) 
```

```{r length exprs, include = FALSE}
length(exprs(gse))
```

To conveniently access the data rows and columns present in `exprs(gse)`, this matrix is assigned to its own variable `ex`.

```{r}
# exprs (gse) is a matrix that we can assign to its own variable, to
# conveniently access the data rows and columns
ex <- exprs(gse)
dim(ex) # 42 sample, 22283 genes
```

The dataset contains gene expression data of 22283 genes (rows) from 42 patients (columns).

```{r, include=FALSE}
colnames(ex)
```

```{r, include = FALSE}
rownames(ex)
```

```{r, include = FALSE}
ex[1:5,]
```

```{r, include=FALSE}
metadata$description
# contains case number
```


## Pre-processing

```{r boxplot original data, warning=FALSE}
# Analyze value distributions
boxplot(ex, main = 'Boxplot of the data before normalization',
        xlab = "Samples",
        ylab = "Expression Value",
        varwidth = TRUE
        )
```

```{r, include=FALSE}
# save plot as pdf
pdf("plots/02_boxplot_no_norm.pdf")
boxplot(ex, main = 'Boxplot of the data before normalization',
        xlab = "Samples",
        ylab = "Expression Value",
        varwidth = TRUE
        )
dev.off()
```

The boxplot shows that scaling is necessary. So, in this case, I try to apply a log transformation to the data.

```{r boxplot log transformation, fig.cap="Boxplot of the data after applying a logarithmic transformation"}
ex2<-log(ex)
ex2 <- na.omit(as.matrix(ex2))
#dim(ex2) # 22283    42 same as before
boxplot(ex2, main = 'Boxplot of the data after applying a logarithmic transformation',
        xlab = "Samples",
        ylab = "Expression Value"
        )
```

```{r, include=FALSE}
# save plot as pdf
pdf("plots/03_boxplot_log_no_norm.pdf")
boxplot(ex2, main = 'Boxplot of the data after applying a logarithmic transformation',
        xlab = "Samples",
        ylab = "Expression Value"
        )
dev.off()
```

From the boxplot after the log transformation, I can see that there is some variation in the median of the samples. So, I try to apply a median normalization to the data after the log transformation.


```{r}
##### FIIIIXXXXX
# MEDIAN NORMALIZATION
normalized.log.ex=scale(log(ex))

# boxplot post median normalization on ex
boxplot(normalized.log.ex, 
        main = 'Boxplot of the data after median normalization',
        xlab = "Samples",
        ylab = "Expression Value")
```

```{r median normalization and boxplot, fig.cap="Boxplot of the data after median normalization"}
# MEDIAN NORMALIZATION
channel.medians=apply(log(ex),2,median)
normalized.log.ex=sweep(log(ex),2,channel.medians,"-")

# boxplot post median normalization on ex
boxplot(normalized.log.ex, 
        main = 'Boxplot of the data after median normalization',
        xlab = "Samples",
        ylab = "Expression Value")
```

```{r, include=FALSE}
# save plot as pdf
pdf("plots/04_boxplot_log_norm.pdf")
boxplot(normalized.log.ex, 
        main = 'Boxplot of the data after median normalization',
        xlab = "Samples",
        ylab = "Expression Value")
dev.off()
```

## PCA
PCA is a dimensionality reduction technique that allows to condense thousands of dimensions into just two or three. For the dataset's samples, the PCA scores display the coordinates in relation to these additional dimensions. 

```{r pca}
pca <- prcomp(t(normalized.log.ex))

summary(pca)
screeplot(pca)
```

To get the summary of the PCA and the plot showing the variance explained by the first 10 components, it is possible to use the functions commented in the chunks above.

However, using `ggplot2` and `factoextra` packages is possible to get a more concise and informative plot reporting the same information.

```{r variance explained by pca}
pcaVar <- get_eig(pca)
pcaVar <- pcaVar$variance.percent[1:10]
screeDf <- data.frame("Dimensions" = as.factor(seq(1,10)),
                      "Percentages" = pcaVar,
                      "Labels" = paste(round(pcaVar, 2), "%"))

p <- ggplot(data = screeDf, aes(x=Dimensions, y=Percentages))+
  geom_bar(stat = "identity", fill = "#d1105a")+
  geom_text(aes(label=Labels), vjust=-0.5, color="black", size=3.6)+
  ggtitle("Scree Plot")+
  ylab("Percentage of variance explained")+
  scale_x_discrete(labels = as.factor(seq(1,10)))
p
```

```{r, include=FALSE}
# save plot as pdf
pdf("plots/05_ScreePlot.pdf")
p
dev.off()
```

The scree plot shows that the first dimensions on the left are the more important because the percentage of variance explained by them is higher. The remaining principal components account for a very small proportion of the variability and are probably unimportant.

Let's try to plot the PCA, looking if we can see a separation between Control and Breast Cancer groups.

```{r PCA for components 1 and 2 control VS Breast cancer without labels}
# draw PCA plot control VS breast cancer
group <- c(rep("cadetblue1",18), rep("red",18), rep("cadetblue1",6) ) 
plot(pca$x[,1], pca$x[,2], xlab="PCA1", ylab="PCA2", main="PCA for components 1 and 2", type="p", pch=10, col=group)
text(pca$x[,1], pca$x[,2], rownames(pca$data), cex=0.75)
legend("topleft", col=c("cadetblue1","red"), legend = c("Control", "Breast Cancer"),
    pch = 20, bty='n', cex=.55)
```

```{r, include=FALSE}
# save plot as pdf
pdf("plots/06_PCA_tumorVScontrol.pdf")
# draw PCA plot control VS breast cancer
group <- c(rep("cadetblue1",18), rep("red",18), rep("cadetblue1",6) ) 
plot(pca$x[,1], pca$x[,2], xlab="PCA1", ylab="PCA2", main="PCA for components 1 and 2", type="p", pch=10, col=group)
text(pca$x[,1], pca$x[,2], rownames(pca$data), cex=0.75)
legend("topleft", col=c("cadetblue1","red"), legend = c("Control", "Breast Cancer"),
    pch = 20, bty='n', cex=.55)
dev.off()
```

```{r PCA for components 1 and 2 control VS Breast cancer with labels, include=FALSE}
# draw PCA plot control VS breast cancer
group <- c(rep("cadetblue1",18), rep("red",18), rep("cadetblue1",6) ) 
plot(pca$x[,1], pca$x[,2], xlab="PCA1", ylab="PCA2", main="PCA for components 1 and 2", type="p", pch=10, col=group)
text(pca$x[,1], pca$x[,2], rownames(pca$x), cex=0.5) # add labels to points
legend("topleft", col=c("cadetblue1","red"), legend = c("Control", "Breast Cancer"),
    pch = 20, bty='n', cex=.55)
```

```{r, include=FALSE}
# save plot as pdf
pdf("plots/07_PCA_tumorVScontrol_labels.pdf")
# draw PCA plot control VS breast cancer
group <- c(rep("cadetblue1",18), rep("red",18), rep("cadetblue1",6) ) 
plot(pca$x[,1], pca$x[,2], xlab="PCA1", ylab="PCA2", main="PCA for components 1 and 2", type="p", pch=10, col=group)
text(pca$x[,1], pca$x[,2], rownames(pca$x), cex=0.5) # add labels to points
legend("topleft", col=c("cadetblue1","red"), legend = c("Control", "Breast Cancer"),
    pch = 20, bty='n', cex=.55)
dev.off()
```

Let's try to add the control subtypes. The vector group used in the PCA plot is based on the data. The samples corresponding to the colors are the following:

-   **Light blue**: reduction mammoplasty (RM) breast epithelium samples

-   **Red**: histologically normal (HN) epithelial samples from breast cancer patient

-   **Purple**: histologically normal breast epithelium (NlEpi) from prophylactic mastectomy patient samples

```{r PCA for components 1 and 2 control subtypes without labels}
# draw PCA plot
group <- c(rep("cadetblue1",18), rep("red",18), rep("purple",6) ) # vector of colors based on the order of my data
plot(pca$x[,1], pca$x[,2], xlab="PCA1", ylab="PCA2", main="PCA for components 1 and 2", type="p", pch=10, col=group)
text(pca$x[,1], pca$x[,2], rownames(pca$data), cex=0.75)
legend("topleft", col=c("cadetblue1","red","purple"), legend = c("Reduction Mammoplasty", "Breast Cancer", "Prophylactic Mastectomy"),
    pch = 20, bty='n', cex=.55)
```

```{r, include=FALSE}
# save plot as pdf
pdf("plots/08_PCA_subtypes_control.pdf")
group <- c(rep("cadetblue1",18), rep("red",18), rep("purple",6) ) # vector of colors based on the order of my data
plot(pca$x[,1], pca$x[,2], xlab="PCA1", ylab="PCA2", main="PCA for components 1 and 2", type="p", pch=10, col=group)
text(pca$x[,1], pca$x[,2], rownames(pca$data), cex=0.75)
legend("topleft", col=c("cadetblue1","red","purple"), legend = c("Reduction Mammoplasty", "Breast Cancer", "Prophylactic Mastectomy"),
    pch = 20, bty='n', cex=.55)
dev.off()
```

```{r PCA for components 1 and 2 control subtypes with labels, include=FALSE}
# draw PCA plot
group <- c(rep("cadetblue1",18), rep("red",18), rep("purple",6) ) # vector of colors based on the order of my data
plot(pca$x[,1], pca$x[,2], xlab="PCA1", ylab="PCA2", main="PCA for components 1 and 2", type="p", pch=10, col=group)
text(pca$x[,1], pca$x[,2], rownames(pca$x), cex=0.5) # add labels
legend("topleft", col=c("cadetblue1","red","purple"), legend = c("Reduction Mammoplasty", "Breast Cancer", "Prophylactic Mastectomy"),
    pch = 20, bty='n', cex=.55)
```

```{r, include=FALSE}
# save plot as pdf
pdf("plots/09_PCA_subtypes_control_labels.pdf")
# draw PCA plot
group <- c(rep("cadetblue1",18), rep("red",18), rep("purple",6) ) # vector of colors based on the order of my data
plot(pca$x[,1], pca$x[,2], xlab="PCA1", ylab="PCA2", main="PCA for components 1 and 2", type="p", pch=10, col=group)
text(pca$x[,1], pca$x[,2], rownames(pca$x), cex=0.5) # add labels
legend("topleft", col=c("cadetblue1","red","purple"), legend = c("Reduction Mammoplasty", "Breast Cancer", "Prophylactic Mastectomy"),
    pch = 20, bty='n', cex=.55)
dev.off()
```

Then, I try to see if there is a separation also inside different types of Breast Cancer.
```{r pca with all subtypes without labels}
# draw PCA plot with all subtypes
group <- c(rep(my_colors[7],18), rep(my_colors[4],9), rep(my_colors[1],9), rep(my_colors[6],6) ) # vector of colors based on the order of my data
plot(pca$x[,1], pca$x[,2], xlab="PCA1", ylab="PCA2", main="PCA for components 1 and 2", type="p", pch=10, col=group)
text(pca$x[,1], pca$x[,2], rownames(pca$data), cex=0.75)
legend("topleft", col=c(my_colors[7],my_colors[4],my_colors[1],my_colors[6]), legend = c("Reduction Mammoplasty", "ER+ Breast Cancer", "ER- Breast Cancer", "Prophylactic Mastectomy"),
    pch = 20, bty='n', cex=.55)
```

```{r, include=FALSE}
# save plot as pdf
pdf("plots/10_PCA_all_subtypes.pdf")
# draw PCA plot with all subtypes
group <- c(rep(my_colors[7],18), rep(my_colors[4],9), rep(my_colors[1],9), rep(my_colors[6],6) ) # vector of colors based on the order of my data
plot(pca$x[,1], pca$x[,2], xlab="PCA1", ylab="PCA2", main="PCA for components 1 and 2", type="p", pch=10, col=group)
text(pca$x[,1], pca$x[,2], rownames(pca$data), cex=0.75)
legend("topleft", col=c(my_colors[7],my_colors[4],my_colors[1],my_colors[6]), legend = c("Reduction Mammoplasty", "ER+ Breast Cancer", "ER- Breast Cancer", "Prophylactic Mastectomy"),
    pch = 20, bty='n', cex=.55)
dev.off()
```

```{r pca with all subtypes with labels, include=FALSE}
# draw PCA plot with all subtypes
group <- c(rep(my_colors[7],18), rep(my_colors[4],9), rep(my_colors[1],9), rep(my_colors[6],6) ) # vector of colors based on the order of my data
plot(pca$x[,1], pca$x[,2], xlab="PCA1", ylab="PCA2", main="PCA for components 1 and 2", type="p", pch=10, col=group)
text(pca$x[,1], pca$x[,2], rownames(pca$x), cex=0.5)
legend("topleft", col=c(my_colors[7],my_colors[4],my_colors[1],my_colors[6]), legend = c("Reduction Mammoplasty", "ER+ Breast Cancer", "ER- Breast Cancer", "Prophylactic Mastectomy"),
    pch = 20, bty='n', cex=.55)
```

```{r, include=FALSE}
# save plot as pdf
pdf("plots/11_PCA_all_subtypes_labels.pdf")
# draw PCA plot with all subtypes
group <- c(rep(my_colors[7],18), rep(my_colors[4],9), rep(my_colors[1],9), rep(my_colors[6],6) ) # vector of colors based on the order of my data
plot(pca$x[,1], pca$x[,2], xlab="PCA1", ylab="PCA2", main="PCA for components 1 and 2", type="p", pch=10, col=group)
text(pca$x[,1], pca$x[,2], rownames(pca$x), cex=0.5)
legend("topleft", col=c(my_colors[7],my_colors[4],my_colors[1],my_colors[6]), legend = c("Reduction Mammoplasty", "ER+ Breast Cancer", "ER- Breast Cancer", "Prophylactic Mastectomy"),
    pch = 20, bty='n', cex=.55)
dev.off()
```

### Interactive PCA plot
Let's try to explore an interactive PCA plot.

```{r fig1 interactive PCA plot, message=FALSE}
components<-pca[["x"]]
components<-data.frame(components)
type<-c(rep("RM", 18), rep("HN",18), rep("NlEpi",6))
components<-cbind(components, type )

fig <- plot_ly(components, x=~PC1, y=~PC2, 
               color=type,colors=c('cadetblue1', 'red','purple'), 
               type='scatter',mode='markers')
fig
```

```{r fig2 interactive PCA plot, message=FALSE}
fig2 <- plot_ly(components, x=~PC1, y=~PC2, z=~PC3, 
                color=type, colors=c('cadetblue1', 'red','purple'),
                mode='markers', marker = list(size = 4))
fig2
```


```{r fig3 interactive PCA plot, message=FALSE}
fig3 <- plot_ly(components, x=~PC1, y=~PC3, 
                color=type, colors=c('cadetblue1', 'red','purple'),
                type='scatter',mode='markers')
fig3
```

```{r UMAP 2D, include=FALSE}
umap_data <- umap::umap(t(normalized.log.ex), 
                        n_neighbors = sqrt(dim(t(normalized.log.ex))[1]),#or the square root of the rows 
                        min_dist = 0.1,         
                        metric = "euclidean",    #you can change it
                        n_components = 2) #used the default ones! 

umap_df <- data.frame(umap_data$layout)
group_data <- data.frame(metadata$specimen.ch1)
umap_df <- cbind(umap_df,group_data)
colnames(umap_df) <- c("X1", "X2", "Group")

umap_df$Group<-c(rep("Reduction Mammoplasty", 18), rep("ER+ Breast Cancer",9), rep("ER- Breast Cancer", 9), rep("Prophylactic Mastectomy",6))

library(plotly)

figUmap <- plot_ly(umap_df, 
                 x = ~X1, y = ~X2, color = umap_df$Group,
                 colors = c('cadetblue1', 'red','purple'),   
                 type = 'scatter',
                 mode = 'markers',
                 size=1)

# Display the 2D scatter plot
figUmap
```

```{r UMAP 3D, include=FALSE}
umap_data_3D <- umap::umap(t(normalized.log.ex), 
                        n_neighbors = sqrt(dim(t(normalized.log.ex))[1]),
                      #or the square root of the rows
                        min_dist = 0.1,         
                        metric = "euclidean",    #you can change it
                        n_components = 3) #used the default ones! 

umap_df_3D <- data.frame(umap_data_3D$layout)
group_data <- data.frame(metadata$specimen.ch1)
umap_df_3D <- cbind(umap_df_3D,group_data)
colnames(umap_df_3D) <- c("X1", "X2", "X3", "Group")

umap_df_3D$Group<-c(rep("Reduction Mammoplasty", 18), rep("ER+ Breast Cancer",9), rep("ER- Breast Cancer", 9), rep("Prophylactic Mastectomy",6))

figUmap_3D <- plot_ly(umap_df_3D, 
                 x = ~X1, y = ~X2, z=~X3, color = umap_df_3D$Group,
                 colors = c('cadetblue1', 'red','purple'),   
                 mode = 'markers',
                 size=1) %>% layout(title = 'Umap 3D')

# Display the 3D scatter plot
figUmap_3D
```

# Clustering
## K-means
```{r K-means}
set.seed(1)
k <- 2 # number of clusters

kmeans_result <- kmeans(t(normalized.log.ex),k)
table(kmeans_result$cluster) # tells how many samples were assigned to each cluster
```

```{r plot kmeans, include=FALSE}
# save plot as pdf
pdf("plots/12_kmeans_2_labels.pdf")
plot(kmeans_result, data=t(normalized.log.ex)) + geom_text(aes(label=colnames(ex)),hjust=0,vjust=0)
```

```{r plot kmeans with metadata title}
plot(kmeans_result, data=t(normalized.log.ex)) + geom_text(aes(label=metadata$disease.state.ch1),hjust=0,vjust=0)
```

```{r, include=FALSE}
# save plot as pdf
pdf("plots/13_kmeans_2_metadata_title.pdf")
plot(kmeans_result, data=t(normalized.log.ex)) + geom_text(aes(label=metadata$disease.state.ch1),hjust=0,vjust=0)
dev.off()
```

```{r cluster plot kmeans 2 clusters}
fviz_cluster(kmeans_result, data = t(normalized.log.ex),
              palette = c("#FF6666", "#33cccc"), 
             geom = "point",
             ellipse.type = "convex", 
             ggtheme = theme_bw()
             )
```
```{r, include=FALSE}
# save plot as pdf
pdf("plots/14_kmeans_2_cluster_plot.pdf")
fviz_cluster(kmeans_result, data = t(normalized.log.ex),
              palette = c("#FF6666", "#33cccc"), 
             geom = "point",
             ellipse.type = "convex", 
             ggtheme = theme_bw()
             )
dev.off()
```

Let's try increasing the number of clusters.
```{r}
set.seed(1)
k <- 4 # number of clusters

kmeans_result <- kmeans(t(normalized.log.ex),k)
table(kmeans_result$cluster) # tells how many samples were assigned to each cluster
```

```{r plot kmeans with metadata specimen}
plot(kmeans_result, data=t(normalized.log.ex)) + geom_text(aes(label=metadata$specimen.ch1),hjust=0,vjust=0)
```

```{r, include=FALSE}
# save plot as pdf
pdf("plots/15_kmeans_4_metadata_title.pdf")
plot(kmeans_result, data=t(normalized.log.ex)) + geom_text(aes(label=metadata$specimen.ch1),hjust=0,vjust=0)
dev.off()
```

```{r cluster plot kmeans 4 clusters}
fviz_cluster(kmeans_result, data = t(normalized.log.ex),
             palette = c("#FF6666", "#99C666", "#33cccc", "#cc66ff"), 
             geom = "point",
             ellipse.type = "convex", 
             ggtheme = theme_bw()
             )
```

```{r, include=FALSE}
# save plot as pdf
pdf("plots/16_kmeans_4_cluster_plot.pdf")
fviz_cluster(kmeans_result, data = t(normalized.log.ex),
             palette = c("#FF6666", "#99C666", "#33cccc", "#cc66ff"), 
             geom = "point",
             ellipse.type = "convex", 
             ggtheme = theme_bw()
             )
dev.off()
```

## Hierarchical

#### FIX DA QUA

```{r determine optimal number of cluster}
# Elbow method
fviz_nbclust(t(normalized.log.ex), FUN = hcut, method = "wss") 
## seems setting number of clusters equal to 2
```

```{r}
# Silhouette method
fviz_nbclust(t(normalized.log.ex), FUN = hcut, method = "silhouette")
## seems setting number of clusters equal to 2
```

We use the Gap statistic to calculate the goodness of clustering.
```{r}
# Gap Statistic Method
gap_stat <- clusGap(t(normalized.log.ex), FUN = hcut, nstart = 25, K.max = 10, B = 50)
# K.max -> the maximum number of clusters to consider
# B -> number of Monte Carlo samples

fviz_gap_stat(gap_stat)

```



```{r}
hc_result <- dist(t(normalized.log.ex)) %>% hclust(method = "ave")
hc_result2<- dist(t(normalized.log.ex), method="euclidean") %>% hclust( method = "complete") 
hc_result3 <- dist(t(normalized.log.ex)) %>% hclust(method = 'single')

k_hc <- 2

groups <- cutree(hc_result, k=k_hc)
table(groups,type)

groups2<-cutree(hc_result2, k=k_hc)
table(groups2,type)

groups3 <- cutree(hc_result3,k=k_hc)
table(groups3,type)

plot(hc_result, hang <- -1, labels=type, main = 'Hierarchical clustering dendrogram, averege')
rect.hclust(hc_result, k = 2, which = NULL, x = NULL, h = NULL, border = 2, cluster = NULL) # red boxes to show groups

plot(hc_result2, hang <- -1, labels=type, main = 'Hierarchical clustering dendrogram, complete')
rect.hclust(hc_result2, k = 2, which = NULL, x = NULL, h = NULL, border = 2, cluster = NULL) # red boxes to show groups

plot(hc_result3, hang <- -1, labels=type, main = 'Hierarchical clustering dendrogram, single')
rect.hclust(hc_result3, k = 2, which = NULL, x = NULL, h = NULL, border = 2, cluster = NULL) # red boxes to show groups

```

## Random forest

```{r}
set.seed(1234)
rf <- randomForest(x=t(normalized.log.ex), y=as.factor(type), ntree=1000)

plot(rf)
```
```{r}
# a trivial test
predict(rf, t(normalized.log.ex[, 1:5]))
# graph of sorted importance values

plot(sort(rf$importance, decreasing=TRUE)) 
#this plot goes into the report

# can also use: varImpPlot(rf)
```


```{r}
varImpPlot(rf)
```


```{r, warning=FALSE}
#extract the most 'important' genes
probe.names <- rownames(rf$importance)
top200 <- probe.names[order(rf$importance, decreasing=TRUE)[1:200]]

write.csv(top200, file = "output/probes-top200.txt", quote=FALSE, row.names =FALSE, col.names=FALSE)
```

## Heatmap
This is optional. Not suggested to include heatmap in the report, because at the end of the project there will be too many graphs and this is not a valuable one.
```{r}
# Look at variable importance
imp.temp <- abs(rf$importance[,])
t <- order(imp.temp,decreasing=TRUE)
plot(c(1:nrow(normalized.log.ex)),imp.temp[t],log='x',cex.main=1.5,
xlab='gene rank',ylab='variable importance',cex.lab=1.5,
pch=16,main='ALL subset results')
```

```{r heatmap}
# Get subset of expression values for 25 most 'important' genes
gn.imp <- names(imp.temp)[t]
gn.25 <- gn.imp[1:25] # vector of top 25 genes, in order
t <- is.element(rownames(normalized.log.ex),gn.25)
sig.ex <- normalized.log.ex[t,] # matrix of expression values, not necessarily in order

## Make a heatmap, with group differences obvious on plot
hmcol <- colorRampPalette(brewer.pal(11,"PuOr"))(256)
colnames(sig.ex) <- group # This will label the heatmap columns
csc <- rep(hmcol[50],30)
csc[group=='T'] <- hmcol[200]
# column side color will be purple for T and orange for B
heatmap(sig.ex, scale="row", col=hmcol, ColSideColors=csc)
```


## Feature selection

```{r}
set.seed(1)
#group <-c(rep("Reduction Mammoplasty", 18), rep("ER+ Breast Cancer",9), rep("ER- Breast Cancer", 9), rep("Prophylactic Mastectomy",6))

group <- c(rep("Control",18), rep("Breast_cancer",18), rep("Control",6))
design <- model.matrix(~0+group)
colnames(design) <- c("Controls","Breast_Cancer")
rownames(design)<-colnames(exprs(gse))
#design
```


```{r}
fit <- lmFit(exprs(gse), design)
cont.matrix <- makeContrasts(contrasts = "Breast_Cancer-Controls", levels=design) 
#cont.matrix
```
```{r}
fit2 <- contrasts.fit(fit, cont.matrix)
fit2
```
```{r}
fit2 <- eBayes(fit2)
fit2
```


